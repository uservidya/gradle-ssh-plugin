apply plugin: 'ssh'

ssh {
    config(StrictHostKeyChecking: 'no')
}

remotes {
    localhost {
        role 'testServers'
        host = 'localhost'
        user = System.properties['user.name']
        identity = file("${System.properties['user.home']}/.ssh/id_rsa")
    }
}


task executeCommand(type: SshTask) {
    session(remotes.localhost) {
        execute "expr $x + $y > '${tempFile.path}'"
    }
}

feature('executing a command') {
    given {
        ext {
            x = (Math.random() * 100) as int
            y = (Math.random() * 100) as int
            tempFile = file("${buildDir}/${UUID.randomUUID()}")
        }
        assert !tempFile.exists()
    }
    when(tasks.executeCommand)
    then {
        assert tempFile.exists()
        assert tempFile.text as int == (x + y)
        assert tempFile.delete()
    }
}


task executeCommandByRole(type: SshTask) {
    session(remotes.role('testServers')) {
        execute "expr $x + $y > '${tempFile.path}'"
    }
}

feature('filter hosts by role') {
    given {
        ext {
            x = (Math.random() * 100) as int
            y = (Math.random() * 100) as int
            tempFile = file("${buildDir}/${UUID.randomUUID()}")
        }
        assert !tempFile.exists()
    }
    when(tasks.executeCommandByRole)
    then {
        assert tempFile.exists()
        assert tempFile.text as int == (x + y)
        assert tempFile.delete()
    }
}


task obtainValue(type: SshTask) {
    session(remotes.localhost) {
        ext.z = execute("expr $x + $y")
    }
}

feature('obtaining a value from the remote command') {
    given {
        ext {
            x = (Math.random() * 100) as int
            y = (Math.random() * 100) as int
        }
    }
    when(tasks.obtainValue)
    then {
        assert z as int == (x + y)
    }
}


task executeConcurrently(type: SshTask) {
    session(remotes.localhost) {
        [0, 2, 4].each { i ->
            executeBackground "sleep ${i} && echo -n ${i}-\${SSH_CONNECTION}- && date"
        }
    }
    session(remotes.localhost) {
        [1, 3, 5].each { i ->
            executeBackground "sleep ${i} && echo -n ${i}-\${SSH_CONNECTION}- && date"
        }
    }
}

feature('executing commands concurrently') {
    given {
    }
    //when('executeConcurrently')
    then {
    }
}


task executeSudoNoPwd(type: SshTask) {
    session(remotes.localhost) {
        execute('sudo env', pty: true)
    }
}

feature('executing a privileged command by password-less sudo') {
    given {
    }
    //when('executeSudoNoPwd')
    then {
    }
}


task executeSudoWithPwd(type: SshTask) {
    doFirst {
        // of course you could just set the password in the remotes configuration,
        // probably reading the password as a property from ~/.gradle/gradle.properties
        remotes.localhost.password = project.sudoPwd
    }
    session(remotes.localhost) {
        println description
        executeSudo('env', pty: true)
    }
}

feature('executing a privileged command with sudo interaction support') {
    given {
    }
    //when('executeSudoWithPwd')
    then {
    }
}


task executeBadCommand(type: SshTask) {
    session(remotes.localhost) {
        execute 'touch /root/test'
    }
}

feature('handling failure of the remote command') {
    given {
    }
    //when('executeBadCommand')
    then {
    }
}


task executeBadCommandInBackground(type: SshTask) {
    session(remotes.localhost) {
        executeBackground 'touch /root/test'
    }
}

feature('handling failure of the remote command in background') {
    given {
    }
    //when('executeBadCommandInBackground')
    then {
    }
}


task executeWithInteractions(type: SshTask) {
    session(remotes.localhost) {
        def oldPassword = 'old-one'
        def newPassword = 'new-one'
        execute('passwd', pty: true) {
            interaction {
                when(partial: ~/.+[Pp]assowrd: */) {
                    standardInput << oldPassword << '\n'
                    when(partial: ~/.+[Pp]assowrd: */) {
                        standardInput << newPassword << '\n'
                    }
                }
            }
        }
    }
}

feature('stream interaction with the remote command') {
    given {
    }
    //when('executeWithInteractions')
    then {
    }
}


task executeSshInTask << {
    def command = "date"
    println command
    sshexec {
        session(remotes.localhost) {
            execute command
        }
    }
}

feature('using sshexec closure in a task') {
    given {
    }
    //when('executeSshInTask')
    then {
    }
}


task putFile(type: SshTask) {
    session(remotes.localhost) {
        put(file('build.gradle').path, '/dev/null')
    }
}

feature('sending files to the remote host') {
    given {
    }
    //when('putFile')
    then {
    }
}


task acquireDataFile(type: SshTask) {
    session(remotes.localhost) {
        execute("expr $x + $y > /tmp/$plusFileName")
        execute("expr $x - $y > /tmp/$minusFileName")

        get("/tmp/$plusFileName", buildDir.path)
        get("/tmp/$minusFileName", buildDir.path)

        execute("rm -v /tmp/$plusFileName")
        execute("rm -v /tmp/$minusFileName")
    }
}

feature('acquiring data files on the remote host') {
    given {
        ext {
            x = (Math.random() * 100) as int
            y = (Math.random() * 100) as int
            plusFileName = UUID.randomUUID().toString()
            minusFileName = UUID.randomUUID().toString()
        }
    }
    when(tasks.acquireDataFile)
    then {
        def plusFile = new File(buildDir, plusFileName as String)
        assert plusFile.text as int == (x + y)
        assert plusFile.delete()

        def minusFile = new File(buildDir, minusFileName as String)
        assert minusFile.text as int == (x - y)
        assert minusFile.delete()
    }
}
